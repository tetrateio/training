/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Modern Bank
 * This is the API exposed to customers of Modern Bank.
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost/v1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    balance: number;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    number: number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    owner: string;
}

/**
 * 
 * @export
 * @interface Newtransaction
 */
export interface Newtransaction {
    /**
     * 
     * @type {number}
     * @memberof Newtransaction
     */
    amount: number;
    /**
     * 
     * @type {number}
     * @memberof Newtransaction
     */
    receiver: number;
    /**
     * 
     * @type {number}
     * @memberof Newtransaction
     */
    sender: number;
}

/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    id: string;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    username: string;
}


/**
 * AccountsApi - fetch parameter creator
 * @export
 */
export const AccountsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new account for a given customer
         * @summary Create a new account for a customer
         * @param {string} owner Owner of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(owner: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createAccount.');
            }
            const localVarPath = `/users/{owner}/accounts`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete account by account number.
         * @summary Delete account by account number
         * @param {string} owner Owner of the account
         * @param {number} number The number of the account that is to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(owner: string, number: number, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteAccount.');
            }
            // verify required parameter 'number' is not null or undefined
            if (number === null || number === undefined) {
                throw new RequiredError('number','Required parameter number was null or undefined when calling deleteAccount.');
            }
            const localVarPath = `/users/{owner}/accounts/{number}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"number"}}`, encodeURIComponent(String(number)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account details
         * @param {string} owner Owner of the account
         * @param {number} number The number of the account that is to be fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByNumber(owner: string, number: number, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getAccountByNumber.');
            }
            // verify required parameter 'number' is not null or undefined
            if (number === null || number === undefined) {
                throw new RequiredError('number','Required parameter number was null or undefined when calling getAccountByNumber.');
            }
            const localVarPath = `/users/{owner}/accounts/{number}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"number"}}`, encodeURIComponent(String(number)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all accounts for a given customer
         * @summary Lists all accounts for a given customer
         * @param {string} owner Owner of the accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts(owner: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listAccounts.');
            }
            const localVarPath = `/users/{owner}/accounts`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new account for a given customer
         * @summary Create a new account for a customer
         * @param {string} owner Owner of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(owner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
            const localVarFetchArgs = AccountsApiFetchParamCreator(configuration).createAccount(owner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete account by account number.
         * @summary Delete account by account number
         * @param {string} owner Owner of the account
         * @param {number} number The number of the account that is to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(owner: string, number: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountsApiFetchParamCreator(configuration).deleteAccount(owner, number, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get account details
         * @param {string} owner Owner of the account
         * @param {number} number The number of the account that is to be fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByNumber(owner: string, number: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
            const localVarFetchArgs = AccountsApiFetchParamCreator(configuration).getAccountByNumber(owner, number, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists all accounts for a given customer
         * @summary Lists all accounts for a given customer
         * @param {string} owner Owner of the accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts(owner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Account>> {
            const localVarFetchArgs = AccountsApiFetchParamCreator(configuration).listAccounts(owner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a new account for a given customer
         * @summary Create a new account for a customer
         * @param {string} owner Owner of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(owner: string, options?: any) {
            return AccountsApiFp(configuration).createAccount(owner, options)(fetch, basePath);
        },
        /**
         * Delete account by account number.
         * @summary Delete account by account number
         * @param {string} owner Owner of the account
         * @param {number} number The number of the account that is to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(owner: string, number: number, options?: any) {
            return AccountsApiFp(configuration).deleteAccount(owner, number, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get account details
         * @param {string} owner Owner of the account
         * @param {number} number The number of the account that is to be fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByNumber(owner: string, number: number, options?: any) {
            return AccountsApiFp(configuration).getAccountByNumber(owner, number, options)(fetch, basePath);
        },
        /**
         * Lists all accounts for a given customer
         * @summary Lists all accounts for a given customer
         * @param {string} owner Owner of the accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts(owner: string, options?: any) {
            return AccountsApiFp(configuration).listAccounts(owner, options)(fetch, basePath);
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Creates a new account for a given customer
     * @summary Create a new account for a customer
     * @param {} owner Owner of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public createAccount(owner: string, options?: any) {
        return AccountsApiFp(this.configuration).createAccount(owner, options)(this.fetch, this.basePath);
    }

    /**
     * Delete account by account number.
     * @summary Delete account by account number
     * @param {} owner Owner of the account
     * @param {} number The number of the account that is to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public deleteAccount(owner: string, number: number, options?: any) {
        return AccountsApiFp(this.configuration).deleteAccount(owner, number, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get account details
     * @param {} owner Owner of the account
     * @param {} number The number of the account that is to be fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountByNumber(owner: string, number: number, options?: any) {
        return AccountsApiFp(this.configuration).getAccountByNumber(owner, number, options)(this.fetch, this.basePath);
    }

    /**
     * Lists all accounts for a given customer
     * @summary Lists all accounts for a given customer
     * @param {} owner Owner of the accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listAccounts(owner: string, options?: any) {
        return AccountsApiFp(this.configuration).listAccounts(owner, options)(this.fetch, this.basePath);
    }

}

/**
 * TransactionsApi - fetch parameter creator
 * @export
 */
export const TransactionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Sends money from one account to another
         * @summary Sends money from one account to another
         * @param {Newtransaction} body Transaction to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction(body: Newtransaction, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createTransaction.');
            }
            const localVarPath = `/transactions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Newtransaction" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific transaction received by a given account
         * @summary Get a specific transaction received by a given account
         * @param {number} receiver Account number that received the transactions
         * @param {string} transaction Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionReceived(receiver: number, transaction: string, options: any = {}): FetchArgs {
            // verify required parameter 'receiver' is not null or undefined
            if (receiver === null || receiver === undefined) {
                throw new RequiredError('receiver','Required parameter receiver was null or undefined when calling getTransactionReceived.');
            }
            // verify required parameter 'transaction' is not null or undefined
            if (transaction === null || transaction === undefined) {
                throw new RequiredError('transaction','Required parameter transaction was null or undefined when calling getTransactionReceived.');
            }
            const localVarPath = `/account/{receiver}/received/{transaction}`
                .replace(`{${"receiver"}}`, encodeURIComponent(String(receiver)))
                .replace(`{${"transaction"}}`, encodeURIComponent(String(transaction)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific transaction sent from a given account
         * @summary Get a specific transaction sent from a given account
         * @param {number} sender Account number that made the transactions
         * @param {string} transaction Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionSent(sender: number, transaction: string, options: any = {}): FetchArgs {
            // verify required parameter 'sender' is not null or undefined
            if (sender === null || sender === undefined) {
                throw new RequiredError('sender','Required parameter sender was null or undefined when calling getTransactionSent.');
            }
            // verify required parameter 'transaction' is not null or undefined
            if (transaction === null || transaction === undefined) {
                throw new RequiredError('transaction','Required parameter transaction was null or undefined when calling getTransactionSent.');
            }
            const localVarPath = `/account/{sender}/sent/{transaction}`
                .replace(`{${"sender"}}`, encodeURIComponent(String(sender)))
                .replace(`{${"transaction"}}`, encodeURIComponent(String(transaction)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all transactions sent to a given account
         * @summary Lists all transactions sent to a given account
         * @param {number} receiver Account number that received the transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsReceived(receiver: number, options: any = {}): FetchArgs {
            // verify required parameter 'receiver' is not null or undefined
            if (receiver === null || receiver === undefined) {
                throw new RequiredError('receiver','Required parameter receiver was null or undefined when calling listTransactionsReceived.');
            }
            const localVarPath = `/account/{receiver}/received`
                .replace(`{${"receiver"}}`, encodeURIComponent(String(receiver)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all transactions sent from a given account
         * @summary Lists all transactions sent from a given account
         * @param {number} sender Account number that made the transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsSent(sender: number, options: any = {}): FetchArgs {
            // verify required parameter 'sender' is not null or undefined
            if (sender === null || sender === undefined) {
                throw new RequiredError('sender','Required parameter sender was null or undefined when calling listTransactionsSent.');
            }
            const localVarPath = `/account/{sender}/sent`
                .replace(`{${"sender"}}`, encodeURIComponent(String(sender)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Sends money from one account to another
         * @summary Sends money from one account to another
         * @param {Newtransaction} body Transaction to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction(body: Newtransaction, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Transaction> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).createTransaction(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a specific transaction received by a given account
         * @summary Get a specific transaction received by a given account
         * @param {number} receiver Account number that received the transactions
         * @param {string} transaction Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionReceived(receiver: number, transaction: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Transaction> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).getTransactionReceived(receiver, transaction, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a specific transaction sent from a given account
         * @summary Get a specific transaction sent from a given account
         * @param {number} sender Account number that made the transactions
         * @param {string} transaction Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionSent(sender: number, transaction: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Transaction> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).getTransactionSent(sender, transaction, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists all transactions sent to a given account
         * @summary Lists all transactions sent to a given account
         * @param {number} receiver Account number that received the transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsReceived(receiver: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Transaction>> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).listTransactionsReceived(receiver, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists all transactions sent from a given account
         * @summary Lists all transactions sent from a given account
         * @param {number} sender Account number that made the transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsSent(sender: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Transaction>> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).listTransactionsSent(sender, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Sends money from one account to another
         * @summary Sends money from one account to another
         * @param {Newtransaction} body Transaction to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction(body: Newtransaction, options?: any) {
            return TransactionsApiFp(configuration).createTransaction(body, options)(fetch, basePath);
        },
        /**
         * Get a specific transaction received by a given account
         * @summary Get a specific transaction received by a given account
         * @param {number} receiver Account number that received the transactions
         * @param {string} transaction Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionReceived(receiver: number, transaction: string, options?: any) {
            return TransactionsApiFp(configuration).getTransactionReceived(receiver, transaction, options)(fetch, basePath);
        },
        /**
         * Get a specific transaction sent from a given account
         * @summary Get a specific transaction sent from a given account
         * @param {number} sender Account number that made the transactions
         * @param {string} transaction Transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionSent(sender: number, transaction: string, options?: any) {
            return TransactionsApiFp(configuration).getTransactionSent(sender, transaction, options)(fetch, basePath);
        },
        /**
         * Lists all transactions sent to a given account
         * @summary Lists all transactions sent to a given account
         * @param {number} receiver Account number that received the transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsReceived(receiver: number, options?: any) {
            return TransactionsApiFp(configuration).listTransactionsReceived(receiver, options)(fetch, basePath);
        },
        /**
         * Lists all transactions sent from a given account
         * @summary Lists all transactions sent from a given account
         * @param {number} sender Account number that made the transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsSent(sender: number, options?: any) {
            return TransactionsApiFp(configuration).listTransactionsSent(sender, options)(fetch, basePath);
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * Sends money from one account to another
     * @summary Sends money from one account to another
     * @param {} body Transaction to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public createTransaction(body: Newtransaction, options?: any) {
        return TransactionsApiFp(this.configuration).createTransaction(body, options)(this.fetch, this.basePath);
    }

    /**
     * Get a specific transaction received by a given account
     * @summary Get a specific transaction received by a given account
     * @param {} receiver Account number that received the transactions
     * @param {} transaction Transaction ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionReceived(receiver: number, transaction: string, options?: any) {
        return TransactionsApiFp(this.configuration).getTransactionReceived(receiver, transaction, options)(this.fetch, this.basePath);
    }

    /**
     * Get a specific transaction sent from a given account
     * @summary Get a specific transaction sent from a given account
     * @param {} sender Account number that made the transactions
     * @param {} transaction Transaction ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionSent(sender: number, transaction: string, options?: any) {
        return TransactionsApiFp(this.configuration).getTransactionSent(sender, transaction, options)(this.fetch, this.basePath);
    }

    /**
     * Lists all transactions sent to a given account
     * @summary Lists all transactions sent to a given account
     * @param {} receiver Account number that received the transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public listTransactionsReceived(receiver: number, options?: any) {
        return TransactionsApiFp(this.configuration).listTransactionsReceived(receiver, options)(this.fetch, this.basePath);
    }

    /**
     * Lists all transactions sent from a given account
     * @summary Lists all transactions sent from a given account
     * @param {} sender Account number that made the transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public listTransactionsSent(sender: number, options?: any) {
        return TransactionsApiFp(this.configuration).listTransactionsSent(sender, options)(this.fetch, this.basePath);
    }

}

/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new user
         * @summary Create a new user identity for a customer
         * @param {User} body Created user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: User, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createUser.');
            }
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete user by username.
         * @summary Delete user
         * @param {string} username The name that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(username: string, options: any = {}): FetchArgs {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user by user name
         * @param {string} username The name that needs to be fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUserName(username: string, options: any = {}): FetchArgs {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling getUserByUserName.');
            }
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user by username.
         * @summary Update user
         * @param {string} username name that need to be updated
         * @param {User} body Updated user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(username: string, body: User, options: any = {}): FetchArgs {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling updateUser.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateUser.');
            }
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new user
         * @summary Create a new user identity for a customer
         * @param {User} body Created user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).createUser(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete user by username.
         * @summary Delete user
         * @param {string} username The name that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(username: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).deleteUser(username, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get user by user name
         * @param {string} username The name that needs to be fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUserName(username: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUserByUserName(username, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update user by username.
         * @summary Update user
         * @param {string} username name that need to be updated
         * @param {User} body Updated user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(username: string, body: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).updateUser(username, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a new user
         * @summary Create a new user identity for a customer
         * @param {User} body Created user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: User, options?: any) {
            return UsersApiFp(configuration).createUser(body, options)(fetch, basePath);
        },
        /**
         * Delete user by username.
         * @summary Delete user
         * @param {string} username The name that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(username: string, options?: any) {
            return UsersApiFp(configuration).deleteUser(username, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get user by user name
         * @param {string} username The name that needs to be fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUserName(username: string, options?: any) {
            return UsersApiFp(configuration).getUserByUserName(username, options)(fetch, basePath);
        },
        /**
         * Update user by username.
         * @summary Update user
         * @param {string} username name that need to be updated
         * @param {User} body Updated user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(username: string, body: User, options?: any) {
            return UsersApiFp(configuration).updateUser(username, body, options)(fetch, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Creates a new user
     * @summary Create a new user identity for a customer
     * @param {} body Created user object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(body: User, options?: any) {
        return UsersApiFp(this.configuration).createUser(body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete user by username.
     * @summary Delete user
     * @param {} username The name that needs to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(username: string, options?: any) {
        return UsersApiFp(this.configuration).deleteUser(username, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get user by user name
     * @param {} username The name that needs to be fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserByUserName(username: string, options?: any) {
        return UsersApiFp(this.configuration).getUserByUserName(username, options)(this.fetch, this.basePath);
    }

    /**
     * Update user by username.
     * @summary Update user
     * @param {} username name that need to be updated
     * @param {} body Updated user object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(username: string, body: User, options?: any) {
        return UsersApiFp(this.configuration).updateUser(username, body, options)(this.fetch, this.basePath);
    }

}

